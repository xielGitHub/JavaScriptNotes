  <!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
  </head>
  <body>
    <div id="root">
      <div class="child-1">
        <div class="child-1-1">
          <div class="child-1-1-1">
            <div class="child-1-1-1-1">
              <div class="child-1-1-1-1-1">
                1-1-1-1-1
              </div>
            </div>
          </div>
        </div>
        <div class="child-1-2">
          <div class="child-1-2-1">
            1-2-1
          </div>
        </div>
        <div class="child-1-3">
          1-3
        </div>
      </div>
      <div class="child-2">
        <div class="child-2-1">
          2-1
        </div>
        <div class="child-2-2">
          2-2
        </div>
      </div>
      <div class="child-3">
        <div class="child-3-1">
          3-1
        </div>
      </div>
      <div class="child-4">
        <div class="child-4-1">
          <div class="child-4-1-1">
            4-1-1
          </div>
          <div class="child-4-1-2">
            4-1-2
          </div>
        </div>
        <div class="child-4-2">
          <div class="child-4-2-1">
            4-2-1
          </div>
          <div class="child-4-2-2">
            4-2-2
          </div>
        </div>
      </div>
    </div>
  </body>
  <script>
    window.onload = () => {
      /*深度优先遍历*/
      // 节点
      const rootDom = document.querySelector('#root');
      // 深度优先
      const deepTraversal = (node, list = []) => {
        if (node) {
          list.push(node);
          const domList = Array.prototype.slice.call(node.children);
          domList.forEach((item) => {
            deepTraversal(item, list);
          })
        }
        return list;
      };
      // 广度优先
      // 思路：获取每一层级的所有节点，存储，然后在获取所有节点的一级子节点，直到最后没有节点为止
      const deepTraversal2 = (node, list = []) => {
        // 临时数组
        let tempList;
        // 如果节点存在
        if (node) {
          // push 第一个的节点
          list.push(node);
          // 转换类数组对象，获取当前节点的所有一级子节点
          let domList = [...node.children];
          // 父元素相邻的子元素
          while(domList.length) {
            // 添加
            list.push(...domList);
            // 临时数组
            tempList = []
            // 遍历当前节点下面的所有一级子节点
            domList.forEach((item) => {
              tempList.push(...item.children);
            });
            // 重复赋值，用于循环
            domList = tempList;
          }
          // 返回
          return list;
        }
      };
      console.log(deepTraversal(rootDom, []));
      console.log(deepTraversal2(rootDom, []));
    }
  </script>
  </html>