闭包

**一、闭包是什么**

闭包是js开发惯用的技巧，什么是闭包？**闭包指的是：能够访问另一个函数作用域的变量的函数**。清晰的讲：闭包就是一个函数，这个函数能够访问其他函数的作用域中的变量

```
function(){
  var a = 1;
  function fn(){
    console.log(a)
  }
  return fn
}()
```

在上面的代码中，在一个立即执行函数中有一个局部变量a，有一个函数fn，在函数fn中可以访问到局部变量a，这就是一个闭包：
如果一个函数使用了它范围外的变量，**这个函数+这个变量**就叫做闭包。

###### 闭包需要函数嵌套函数，再return一个函数吗？

- 把a嵌套在一个立即执行函数里是为了获得一个局部变量，如果不把a放在函数里，a就是一个全局变量，无法达到闭包的目的——隐藏变量。
  所以嵌套函数是为了获得一个局部变量，与闭包无关。
- return fn 这是为了让外面可以访问到fn这个函数。
  所以 return 是为了fn能被使用，也与闭包无关

**二、变量的作用域**

要理解闭包，首先必须理解Javascript特殊的变量作用域。

变量的作用域无非就是两种：全局变量和局部变量。

Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。

> 　　var n=999;
>
> 　　function f1(){
> 　　　　alert(n);
> 　　}
>
> 　　f1(); // 999

另一方面，在函数外部自然无法读取函数内的局部变量。

> 　　function f1(){
> 　　　　var n=999;
> 　　}
>
> 　　alert(n); // error

这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！

> 　　function f1(){
> 　　　　n=999;
> 　　}
>
> 　　f1();
>
> 　　alert(n); // 999

**三、如何从外部读取局部变量？**

出于种种原因，我们有时候需要得到函数内的局部变量。但是，前面已经说过了，正常情况下，这是办不到的，只有通过变通方法才能实现。

那就是在函数的内部，再定义一个函数。

> 　　function f1(){
>
> 　　　　var n=999;
>
> 　　　　function f2(){
> 　　　　　　alert(n); // 999
> 　　　　}
>
> 　　}

在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是Javascript语言特有的"链式作用域"结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。

既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！

> 　　function f1(){
>
> 　　　　var n=999;
>
> 　　　　function f2(){
> 　　　　　　alert(n); 
> 　　　　}
>
> 　　　　return f2;
>
> 　　}
>
> 　　var result=f1();
>
> 　　result(); // 999

**四、闭包的用途**

闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。

**五、闭包的优缺点**

function f1() {

    //闭包f2被外引用始终存在内存中，而它所依赖的f1也会始终存在

    //所以n,m都是始终存在，删除闭包直接f1=null；

    n=1,m=100;

    madd=function(){

    	m+=10;

    	alert(m);

    }  //全局变量madd

    function f2(){

    	n+=1;

    	alert(n);

    }

    return f2;

    }

    var a=f1(); //将子函数返回赋值给了变量a

    a();

    madd();

    //madd的值是一个匿名函数，同时是一个闭包，实现了外部对函数内部进行操作

**优点**：

在内存中维持一个变量，由于闭包，f1中的n只有通过f2方法访问到，无法通过其他途径访问修改，从而达到了保护变量安全的效果；通过闭包实现了js私有属性和私有方法的效果；

**注意点**：

·闭包会使函数中的变量一直存在内存上会导致内存消耗过大，所以不能滥用闭包，否则会造成网页性能问题，IE可能会造成内存溢出。最好的方式是在退出闭包前将不必要的局部变量删除。

·JavaScript垃圾回收机制，如果一个对象不再被引用，那么这个对象就会被GC回收，如果两个对象相互引用，而不再被第三方引用，那么这两个对象会被GC回收，上述父函数被子函数引用，子函数又被外部c引用，这就是父函数不被回收的原因；

相关文章链接：http://www.cnblogs.com/dolphinX/archive/2012/09/29/2708763.html

相关文章链接：https://www.jianshu.com/p/26c81fde22fb

